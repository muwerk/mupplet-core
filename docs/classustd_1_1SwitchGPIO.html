<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>muwerk mupplet Core Library: ustd::SwitchGPIO Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">muwerk mupplet Core Library
   </div>
   <div id="projectbrief">muwerk applets; mupplets: functional units that support specific hardware or reusable applications</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceustd.html">ustd</a></li><li class="navelem"><a class="el" href="classustd_1_1SwitchGPIO.html">SwitchGPIO</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classustd_1_1SwitchGPIO-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ustd::SwitchGPIO Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>mupplet-core GPIO Switch class  
 <a href="classustd_1_1SwitchGPIO.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="switch__gpio_8h_source.html">switch_gpio.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aac5cfabca58d80cdb6cabaa2ed8fd0a2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustd_1_1SwitchGPIO.html#aac5cfabca58d80cdb6cabaa2ed8fd0a2">Mode</a> { <br />
&#160;&#160;<a class="el" href="classustd_1_1SwitchGPIO.html#aac5cfabca58d80cdb6cabaa2ed8fd0a2aa5fd606d7173334f47117355cedd94d3">Default</a>
, <a class="el" href="classustd_1_1SwitchGPIO.html#aac5cfabca58d80cdb6cabaa2ed8fd0a2a631ea6635258fb37b95ce7e33b54f22d">Rising</a>
, <a class="el" href="classustd_1_1SwitchGPIO.html#aac5cfabca58d80cdb6cabaa2ed8fd0a2a7925d13fe881f08310f23dd98be61981">Falling</a>
, <a class="el" href="classustd_1_1SwitchGPIO.html#aac5cfabca58d80cdb6cabaa2ed8fd0a2a37a2caecebfe7cad6e8a3a797b790213">Flipflop</a>
, <br />
&#160;&#160;<a class="el" href="classustd_1_1SwitchGPIO.html#aac5cfabca58d80cdb6cabaa2ed8fd0a2aafb716daf8ada32323faa3e32d5e03d2">Timer</a>
, <a class="el" href="classustd_1_1SwitchGPIO.html#aac5cfabca58d80cdb6cabaa2ed8fd0a2acc355080f672d2c1f91eb837a7b4877f">Duration</a>
<br />
 }</td></tr>
<tr class="separator:aac5cfabca58d80cdb6cabaa2ed8fd0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adf4d56ae17a199f86aca4472b827c66c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustd_1_1SwitchGPIO.html#adf4d56ae17a199f86aca4472b827c66c">SwitchGPIO</a> (String name, uint8_t port, <a class="el" href="classustd_1_1SwitchGPIO.html#aac5cfabca58d80cdb6cabaa2ed8fd0a2">Mode</a> mode=Mode::Default, bool activeLogic=false, String customTopic=&quot;&quot;, int8_t interruptIndex=-1, unsigned long debounceTimeMs=0)</td></tr>
<tr class="separator:adf4d56ae17a199f86aca4472b827c66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63eead25b5bc5f3b62e5d6779f4333d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustd_1_1SwitchGPIO.html#a63eead25b5bc5f3b62e5d6779f4333d0">setDebounce</a> (long ms)</td></tr>
<tr class="separator:a63eead25b5bc5f3b62e5d6779f4333d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ab59422d91cf7eccae7e0408eacd8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustd_1_1SwitchGPIO.html#a09ab59422d91cf7eccae7e0408eacd8d">setTimerDuration</a> (unsigned long ms)</td></tr>
<tr class="separator:a09ab59422d91cf7eccae7e0408eacd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194439b9fbc6bfa2f8096225f31101b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustd_1_1SwitchGPIO.html#a194439b9fbc6bfa2f8096225f31101b7">setMode</a> (<a class="el" href="classustd_1_1SwitchGPIO.html#aac5cfabca58d80cdb6cabaa2ed8fd0a2">Mode</a> newmode, unsigned long duration=0)</td></tr>
<tr class="separator:a194439b9fbc6bfa2f8096225f31101b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3763b06ec7406bca9b11f1483378766"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustd_1_1SwitchGPIO.html#ad3763b06ec7406bca9b11f1483378766">begin</a> (Scheduler *_pSched)</td></tr>
<tr class="separator:ad3763b06ec7406bca9b11f1483378766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26819f99ae1fe609c14cfd73e2f27d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustd_1_1SwitchGPIO.html#ad26819f99ae1fe609c14cfd73e2f27d9">setLogicalState</a> (bool newLogicalState)</td></tr>
<tr class="separator:ad26819f99ae1fe609c14cfd73e2f27d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17851b734647d83e6d1189a4ec780e74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustd_1_1SwitchGPIO.html#a17851b734647d83e6d1189a4ec780e74">setToggle</a> ()</td></tr>
<tr class="separator:a17851b734647d83e6d1189a4ec780e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2dc12cade81c348e791e7e80ffde4e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classustd_1_1SwitchGPIO.html#aa2dc12cade81c348e791e7e80ffde4e6">setPulse</a> ()</td></tr>
<tr class="separator:aa2dc12cade81c348e791e7e80ffde4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>mupplet-core GPIO Switch class </p>
<p>The Switch class allows to integrate switches and buttons in muwerk by either polling GPIOs or by using interrupts. Optional automatic debouncing is provided for both modes, but mostly important for interrupt-mode.</p>
<p>In mode falling or rising, only a 'trigger' event is generated, there is no on or off state. This is useful to implement push-button events.</p>
<p>The mupplet can automatically generate short- and long-press events and provide timing information about length of button presses.</p>
<p>Other options include flip-flop mode and monostable impulses.</p>
<p>The physical hardware of a switch can be overriden by a software <a class="el" href="classustd_1_1SwitchGPIO.html#ad26819f99ae1fe609c14cfd73e2f27d9">setLogicalState</a>, a switch stays in override-mode until the next state change of the physical hardware is detected.</p>
<h2>Messages</h2>
<h3>Messages sent by the switch mupplet:</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">topic   </th><th class="markdownTableHeadNone">message body   </th><th class="markdownTableHeadNone">comment    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>&lt;mupplet-name&gt;/switch/state</code>   </td><td class="markdownTableBodyNone"><code>on</code>, <code>off</code> or <code>trigger</code>   </td><td class="markdownTableBodyNone">switch state, usually <code>on</code> or <code>off</code>. In modes <code>falling</code> and <code>rising</code> only <code>trigger</code> messages are sent on rising or falling signal.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>&lt;mupplet-name&gt;/switch/debounce</code>   </td><td class="markdownTableBodyNone">&lt;time-in-ms&gt;   </td><td class="markdownTableBodyNone">reply to <code>&lt;mupplet-name&gt;/switch/debounce/get</code>, switch debounce time in ms [0..1000]ms.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>&lt;custom-topic&gt;</code>   </td><td class="markdownTableBodyNone"><code>on</code>, <code>off</code> or <code>trigger</code>   </td><td class="markdownTableBodyNone">If a custom-topic is given during switch init, an addtional message is publish on switch state changes with that topic, The message is identical to ../switch/state', usually <code>on</code> or <code>off</code>. In modes <code>falling</code> and <code>rising</code> only <code>trigger</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>&lt;mupplet-name&gt;/switch/shortpress</code>   </td><td class="markdownTableBodyNone"><code>trigger</code>   </td><td class="markdownTableBodyNone">Switch is in <code>duration</code> mode, and button is pressed for less than <code>&lt;shortpress_ms&gt;</code> (default 3000ms).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>&lt;mupplet-name&gt;/switch/longpress</code>   </td><td class="markdownTableBodyNone"><code>trigger</code>   </td><td class="markdownTableBodyNone">Switch is in <code>duration</code> mode, and button is pressed for less than <code>&lt;longpress_ms&gt;</code> (default 30000ms), yet longer than shortpress.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>&lt;mupplet-name&gt;/switch/verylongtpress</code>   </td><td class="markdownTableBodyNone"><code>trigger</code>   </td><td class="markdownTableBodyNone">Switch is in <code>duration</code> mode, and button is pressed for longer than <code>&lt;longpress_ms&gt;</code> (default 30000ms).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>&lt;mupplet-name&gt;/switch/duration</code>   </td><td class="markdownTableBodyNone"><code>&lt;ms&gt;</code>   </td><td class="markdownTableBodyNone">Switch is in <code>duration</code> mode, message contains the duration in ms the switch was pressed.   </td></tr>
</table>
<h3>Message received by the switch mupplet:</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">topic   </th><th class="markdownTableHeadNone">message body   </th><th class="markdownTableHeadNone">comment    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>&lt;mupplet-name&gt;/switch/set</code>   </td><td class="markdownTableBodyNone"><code>on</code>, <code>off</code>, <code>true</code>, <code>false</code>, <code>toggle</code>   </td><td class="markdownTableBodyNone">Override switch setting. When setting the switch state via message, the hardware port remains overridden until the hardware changes state (e.g. button is physically pressed). Sending a <code>switch/set</code> message puts the switch in override-mode: e.g. when sending <code>switch/set</code> <code>on</code>, the state of the button is signalled <code>on</code>, even so the physical button might be off. Next time the physical button is pressed (or changes state), override mode is stopped, and the state of the actual physical button is published again.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>&lt;mupplet-name&gt;/switch/mode/set</code>   </td><td class="markdownTableBodyNone"><code>default</code>, <code>rising</code>, <code>falling</code>, <code>flipflop</code>, <code>timer &lt;time-in-ms&gt;</code>, <code>duration [shortpress_ms[,longpress_ms]]</code>   </td><td class="markdownTableBodyNone">Mode <code>default</code> sends <code>on</code> when a button is pushed, <code>off</code> on release. <code>falling</code> and <code>rising</code> send <code>trigger</code> on corresponding signal change. <code>flipflop</code> changes the state of the logical switch on each change from button on to off. <code>timer</code> keeps the switch on for the specified duration (ms). <code>duration</code> mode sends messages <code>switch/shortpress</code>, if button was pressed for less than <code>&lt;shortpress_ms&gt;</code> (default 3000ms), <code>switch/longpress</code> if pressed less than <code>&lt;longpress_ms&gt;</code>, and <code>switch/verylongpress</code> for longer presses.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>&lt;mupplet-name&gt;/switch/debounce/set</code>   </td><td class="markdownTableBodyNone">&lt;time-in-ms&gt;   </td><td class="markdownTableBodyNone">String encoded switch debounce time in ms, [0..1000]ms. Default is 20ms. This is especially need, when switch is created in interrupt mode (see comment in <a href="https://github.com/muwerk/Examples/tree/master/led">example</a>).   </td></tr>
</table>
<h2>Sample Switch Integration</h2>
<p>XXX</p>
<p>More information: <a href="https://github.com/muwerk/mupplet-core/blob/master/extras/Switch-notes.md">Switch application notes</a> </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aac5cfabca58d80cdb6cabaa2ed8fd0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5cfabca58d80cdb6cabaa2ed8fd0a2">&#9670;&nbsp;</a></span>Mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classustd_1_1SwitchGPIO.html#aac5cfabca58d80cdb6cabaa2ed8fd0a2">ustd::SwitchGPIO::Mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The mode switch is operating in </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aac5cfabca58d80cdb6cabaa2ed8fd0a2aa5fd606d7173334f47117355cedd94d3"></a>Default&#160;</td><td class="fielddoc"><p>Standard mode, changes between on-state (button pressed) and off-state (released) </p>
</td></tr>
<tr><td class="fieldname"><a id="aac5cfabca58d80cdb6cabaa2ed8fd0a2a631ea6635258fb37b95ce7e33b54f22d"></a>Rising&#160;</td><td class="fielddoc"><p>Act on level changes LOW-&gt;HIGH, generates a 'trigger' message (push-button event) </p>
</td></tr>
<tr><td class="fieldname"><a id="aac5cfabca58d80cdb6cabaa2ed8fd0a2a7925d13fe881f08310f23dd98be61981"></a>Falling&#160;</td><td class="fielddoc"><p>Act on level changes HIGH-&gt;LOW, generates a 'trigger' message (push-button event) <br  />
 </p>
</td></tr>
<tr><td class="fieldname"><a id="aac5cfabca58d80cdb6cabaa2ed8fd0a2a37a2caecebfe7cad6e8a3a797b790213"></a>Flipflop&#160;</td><td class="fielddoc"><p>Each trigger changes state for on to off or vice-versa </p>
</td></tr>
<tr><td class="fieldname"><a id="aac5cfabca58d80cdb6cabaa2ed8fd0a2aafb716daf8ada32323faa3e32d5e03d2"></a>Timer&#160;</td><td class="fielddoc"><p>Each trigger generates an on-state for a given time (monostable) </p>
</td></tr>
<tr><td class="fieldname"><a id="aac5cfabca58d80cdb6cabaa2ed8fd0a2acc355080f672d2c1f91eb837a7b4877f"></a>Duration&#160;</td><td class="fielddoc"><p>Timing information is provided: SHORTPRESS, LONGPRESS, VERYLONGPRESS and absolute duration </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adf4d56ae17a199f86aca4472b827c66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4d56ae17a199f86aca4472b827c66c">&#9670;&nbsp;</a></span>SwitchGPIO()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ustd::SwitchGPIO::SwitchGPIO </td>
          <td>(</td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classustd_1_1SwitchGPIO.html#aac5cfabca58d80cdb6cabaa2ed8fd0a2">Mode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code>Mode::Default</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>activeLogic</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">String&#160;</td>
          <td class="paramname"><em>customTopic</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>interruptIndex</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>debounceTimeMs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Instantiate a muwerk switch</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the switch mupplet, referenced in pub/sub messages </td></tr>
    <tr><td class="paramname">port</td><td>GPIO port the switch is connected to. </td></tr>
    <tr><td class="paramname">mode</td><td>The <a class="el" href="classustd_1_1SwitchGPIO.html#aac5cfabca58d80cdb6cabaa2ed8fd0a2">Mode</a> of operation of the switch. </td></tr>
    <tr><td class="paramname">activeLogic</td><td>'false' indicates that signal level LOW is switch active (default), 'true' indicates that signal level HIGH is switch active. </td></tr>
    <tr><td class="paramname">customTopic</td><td>An optional topic string that is sent in addition to the standard &lt;mupplet-name&gt;/switch/state message. Useful to indicate specific usages, e.g. a movement detector connected to the switch input. </td></tr>
    <tr><td class="paramname">interruptIndex</td><td>Optional ESP interrupt index 0..15, must be unique in a given system. </td></tr>
    <tr><td class="paramname">debounceTimeMs</td><td>Debouncing treshhold, important if used in interrupt mode.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad3763b06ec7406bca9b11f1483378766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3763b06ec7406bca9b11f1483378766">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustd::SwitchGPIO::begin </td>
          <td>(</td>
          <td class="paramtype">Scheduler *&#160;</td>
          <td class="paramname"><em>_pSched</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize GPIOs and activate switch hardware</p>
<h3>Messages sent by the switch mupplet on state changes:</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">topic   </th><th class="markdownTableHeadNone">message body   </th><th class="markdownTableHeadNone">comment    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>&lt;mupplet-name&gt;/switch/state</code>   </td><td class="markdownTableBodyNone"><code>on</code>, <code>off</code> or <code>trigger</code>   </td><td class="markdownTableBodyNone">switch state, usually <code>on</code> or <code>off</code>. In modes <code>falling</code> and <code>rising</code> only <code>trigger</code> messages are sent on rising or falling signal.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>&lt;mupplet-name&gt;/switch/debounce</code>   </td><td class="markdownTableBodyNone">&lt;time-in-ms&gt;   </td><td class="markdownTableBodyNone">reply to <code>&lt;mupplet-name&gt;/switch/debounce/get</code>, switch debounce time in ms [0..1000]ms.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>&lt;custom-topic&gt;</code>   </td><td class="markdownTableBodyNone"><code>on</code>, <code>off</code> or <code>trigger</code>   </td><td class="markdownTableBodyNone">If a custom-topic is given during switch init, an addtional message is publish on switch state changes with that topic, The message is identical to ../switch/state', usually <code>on</code> or <code>off</code>. In modes <code>falling</code> and <code>rising</code> only <code>trigger</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>&lt;mupplet-name&gt;/switch/shortpress</code>   </td><td class="markdownTableBodyNone"><code>trigger</code>   </td><td class="markdownTableBodyNone">Switch is in <code>duration</code> mode, and button is pressed for less than <code>&lt;shortpress_ms&gt;</code> (default 3000ms).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>&lt;mupplet-name&gt;/switch/longpress</code>   </td><td class="markdownTableBodyNone"><code>trigger</code>   </td><td class="markdownTableBodyNone">Switch is in <code>duration</code> mode, and button is pressed for less than <code>&lt;longpress_ms&gt;</code> (default 30000ms), yet longer than shortpress.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>&lt;mupplet-name&gt;/switch/verylongtpress</code>   </td><td class="markdownTableBodyNone"><code>trigger</code>   </td><td class="markdownTableBodyNone">Switch is in <code>duration</code> mode, and button is pressed for longer than <code>&lt;longpress_ms&gt;</code> (default 30000ms).    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>&lt;mupplet-name&gt;/switch/duration</code>   </td><td class="markdownTableBodyNone"><code>&lt;ms&gt;</code>   </td><td class="markdownTableBodyNone">Switch is in <code>duration</code> mode, message contains the duration in ms the switch was pressed.   </td></tr>
</table>
<h3>The switch mupplet now listens to the following messages:</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">topic   </th><th class="markdownTableHeadNone">message body   </th><th class="markdownTableHeadNone">comment    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>&lt;mupplet-name&gt;/switch/set</code>   </td><td class="markdownTableBodyNone"><code>on</code>, <code>off</code>, <code>true</code>, <code>false</code>, <code>toggle</code>   </td><td class="markdownTableBodyNone">Override switch setting. When setting the switch state via message, the hardware port remains overridden until the hardware changes state (e.g. button is physically pressed). Sending a <code>switch/set</code> message puts the switch in override-mode: e.g. when sending <code>switch/set</code> <code>on</code>, the state of the button is signalled <code>on</code>, even so the physical button might be off. Next time the physical button is pressed (or changes state), override mode is stopped, and the state of the actual physical button is published again.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>&lt;mupplet-name&gt;/switch/mode/set</code>   </td><td class="markdownTableBodyNone"><code>default</code>, <code>rising</code>, <code>falling</code>, <code>flipflop</code>, <code>timer &lt;time-in-ms&gt;</code>, <code>duration [shortpress_ms[,longpress_ms]]</code>   </td><td class="markdownTableBodyNone">Mode <code>default</code> sends <code>on</code> when a button is pushed, <code>off</code> on release. <code>falling</code> and <code>rising</code> send <code>trigger</code> on corresponding signal change. <code>flipflop</code> changes the state of the logical switch on each change from button on to off. <code>timer</code> keeps the switch on for the specified duration (ms). <code>duration</code> mode sends messages <code>switch/shortpress</code>, if button was pressed for less than <code>&lt;shortpress_ms&gt;</code> (default 3000ms), <code>switch/longpress</code> if pressed less than <code>&lt;longpress_ms&gt;</code>, and <code>switch/verylongpress</code> for longer presses.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>&lt;mupplet-name&gt;/switch/debounce/set</code>   </td><td class="markdownTableBodyNone">&lt;time-in-ms&gt;   </td><td class="markdownTableBodyNone">String encoded switch debounce time in ms, [0..1000]ms. Default is 20ms. This is especially need, when switch is created in interrupt mode (see comment in <a href="https://github.com/muwerk/Examples/tree/master/led">example</a>).   </td></tr>
</table>

</div>
</div>
<a id="a63eead25b5bc5f3b62e5d6779f4333d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63eead25b5bc5f3b62e5d6779f4333d0">&#9670;&nbsp;</a></span>setDebounce()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustd::SwitchGPIO::setDebounce </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change debounce time</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>New debounce time in ms. In interrupt mode values between 5-20ms are useful.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad26819f99ae1fe609c14cfd73e2f27d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26819f99ae1fe609c14cfd73e2f27d9">&#9670;&nbsp;</a></span>setLogicalState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustd::SwitchGPIO::setLogicalState </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newLogicalState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Temporarily override the physical state of the switch with a software-induced state</p>
<p>The new logical state (which might not reflect the actual hardware) remains in effect until a state-change of the actual hardware is detected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newLogicalState</td><td>true: switch is simulated on, false, switch is simulated off.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a194439b9fbc6bfa2f8096225f31101b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194439b9fbc6bfa2f8096225f31101b7">&#9670;&nbsp;</a></span>setMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustd::SwitchGPIO::setMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classustd_1_1SwitchGPIO.html#aac5cfabca58d80cdb6cabaa2ed8fd0a2">Mode</a>&#160;</td>
          <td class="paramname"><em>newmode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>duration</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the switch into one of the switch <a class="el" href="classustd_1_1SwitchGPIO.html#aac5cfabca58d80cdb6cabaa2ed8fd0a2">Mode</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newmode</td><td>The new <a class="el" href="classustd_1_1SwitchGPIO.html#aac5cfabca58d80cdb6cabaa2ed8fd0a2">Mode</a> </td></tr>
    <tr><td class="paramname">duration</td><td>For Mode::Timer: the length in ms the switch stays on on reception of a trigger.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2dc12cade81c348e791e7e80ffde4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2dc12cade81c348e791e7e80ffde4e6">&#9670;&nbsp;</a></span>setPulse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustd::SwitchGPIO::setPulse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Temporarily override the physical state of the switch by simulating a pulse.</p>
<p>The new logical state (which might not reflect the actual hardware) remains in effect until a state-change of the actual hardware is detected.</p>

</div>
</div>
<a id="a09ab59422d91cf7eccae7e0408eacd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ab59422d91cf7eccae7e0408eacd8d">&#9670;&nbsp;</a></span>setTimerDuration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustd::SwitchGPIO::setTimerDuration </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the duration of on-state in Mode::Timer</p>
<p>A switch in Mode::Timer stays on for the time of ms, if a trigger is received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ms</td><td>time in ms.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17851b734647d83e6d1189a4ec780e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17851b734647d83e6d1189a4ec780e74">&#9670;&nbsp;</a></span>setToggle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ustd::SwitchGPIO::setToggle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Temporarily override the physical state of the switch by toggling the current state.</p>
<p>The new logical state (which might not reflect the actual hardware) remains in effect until a state-change of the actual hardware is detected.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="switch__gpio_8h_source.html">switch_gpio.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
